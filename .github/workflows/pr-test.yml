name: PR Tests

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'gitea/**'
      - 'manifests/**'
      - '.github/workflows/pr-test.yml'  # Allow testing the workflow itself

env:
  REPLICATED_APP: gitea-mastodon
  REPLICATED_API_ORIGIN: https://api.replicated.com/vendor

jobs:
  test-embedded-cluster:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install Replicated CLI
        run: |
          curl -s https://api.github.com/repos/replicatedhq/replicated/releases/latest \
          | grep "browser_download_url.*linux_amd64.tar.gz" \
          | cut -d : -f 2,3 \
          | tr -d \" \
          | wget -O replicated.tar.gz -qi -
          tar xf replicated.tar.gz
          sudo mv replicated /usr/local/bin/

      - name: Generate test version
        id: version
        run: |
          # Generate unique version for PR testing using PR number, run number, and commit SHA
          COMMIT_SHORT=$(git rev-parse --short HEAD)
          VERSION="pr${{ github.event.pull_request.number }}-r${{ github.run_number }}-${COMMIT_SHORT}"
          echo "test_version=$VERSION" >> $GITHUB_OUTPUT
          echo "Generated unique test version: $VERSION"

      - name: Package Helm chart
        run: |
          # Clean any existing packages
          rm -f manifests/*.tgz

          # Package the chart
          helm package gitea -d manifests -u
          echo "Packaged chart:"
          ls -la manifests/*.tgz

      - name: Create test release
        run: |
          # Create release on Unstable channel for testing
          replicated release create \
            --lint \
            --yaml-dir ./manifests \
            --promote Unstable \
            --version "${{ steps.version.outputs.test_version }}"
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}
          REPLICATED_APP: ${{ env.REPLICATED_APP }}

      - name: Create test VM
        id: vm
        run: |
          # Create VM for testing with 10 minute wait and unique name
          COMMIT_SHORT=$(git rev-parse --short HEAD)
          VM_NAME="pr-test-${{ github.event.pull_request.number }}-r${{ github.run_number }}-${COMMIT_SHORT}"
          echo "Creating VM for PR testing: $VM_NAME (waiting up to 10 minutes)..."
          VM_OUTPUT=$(replicated vm create \
            --distribution ubuntu \
            --version 22.04 \
            --instance-type r1.small \
            --name "$VM_NAME" \
            --wait 10m \
            --output json)

          echo "VM creation output:"
          echo "$VM_OUTPUT"

          # Try to extract VM ID - handle both object and array responses
          VM_ID=$(echo "$VM_OUTPUT" | jq -r 'if type == "array" then .[0].id else .id end')

          if [[ -z "$VM_ID" || "$VM_ID" == "null" ]]; then
            echo "‚ùå Failed to get VM ID from output"
            exit 1
          fi

          echo "vm_id=$VM_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ VM created and ready: $VM_ID"
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}

      - name: Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VM_SSH_PRIVATE_KEY }}

      - name: Setup SSH known hosts and transfer files
        run: |
          # Setup SSH known hosts (testing key sync fix)
          mkdir -p ~/.ssh
          ssh-keyscan replicatedvm.com >> ~/.ssh/known_hosts

          # Get SCP endpoint for file transfers
          SCP_ENDPOINT=$(replicated vm scp-endpoint ${{ steps.vm.outputs.vm_id }} --username ajp-io)
          echo "SCP endpoint: $SCP_ENDPOINT"

          # Make scripts executable
          chmod +x scripts/test-embedded-install.sh

          # Transfer test files to VM home directory first
          scp -O -o StrictHostKeyChecking=no test/embedded-config.yaml $SCP_ENDPOINT/config.yaml
          scp -O -o StrictHostKeyChecking=no scripts/test-embedded-install.sh $SCP_ENDPOINT/test.sh

          # Get SSH endpoint and move files to /tmp
          SSH_ENDPOINT=$(replicated vm ssh-endpoint ${{ steps.vm.outputs.vm_id }} --username ajp-io)
          ssh -o StrictHostKeyChecking=no $SSH_ENDPOINT 'sudo mv config.yaml /tmp/ && sudo mv test.sh /tmp/ && ls -la /tmp/'

          echo "Files transferred successfully"
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}

      - name: Run embedded cluster installation test
        id: test
        run: |
          # Get SSH endpoint for connection (fallback to explicit username until auto-detection works)
          SSH_ENDPOINT=$(replicated vm ssh-endpoint ${{ steps.vm.outputs.vm_id }} --username ajp-io)
          echo "SSH endpoint: $SSH_ENDPOINT"

          # Run the test script on the VM with the test version
          echo "Running embedded cluster installation test for version: ${{ steps.version.outputs.test_version }}"
          ssh -o StrictHostKeyChecking=no $SSH_ENDPOINT 'chmod +x /tmp/test.sh && sudo TEST_VERSION="${{ steps.version.outputs.test_version }}" /tmp/test.sh'

          echo "Test completed successfully!"
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}

      - name: Cleanup VM
        if: success()
        run: |
          if [[ -n "${{ steps.vm.outputs.vm_id }}" ]]; then
            echo "‚úÖ Test passed! Cleaning up VM: ${{ steps.vm.outputs.vm_id }}"
            replicated vm rm ${{ steps.vm.outputs.vm_id }} || true
            echo "VM cleanup completed"
          fi
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}

      - name: Clean up test artifacts
        if: always()
        run: |
          rm -f manifests/*.tgz
          echo "Cleaned up build artifacts"

      - name: Report test results
        if: always()
        run: |
          TEST_OUTCOME="${{ steps.test.outcome }}"

          if [[ "$TEST_OUTCOME" == "success" ]]; then
            echo "‚úÖ Embedded cluster installation test PASSED"
            echo "The changes in this PR work correctly with embedded cluster deployment."
          elif [[ "$TEST_OUTCOME" == "failure" ]]; then
            echo "‚ùå Embedded cluster installation test FAILED"
            echo "There may be issues with the changes in this PR. Please review the logs above."

            # Show VM info for debugging
            if [[ -n "${{ steps.vm.outputs.vm_id }}" ]]; then
              echo ""
              echo "üîç Debug Information:"
              echo "VM ID: ${{ steps.vm.outputs.vm_id }}"
              echo "VM has been left running for debugging (24h TTL)"
              echo "You can SSH to it using: ssh \$(replicated vm ssh-endpoint ${{ steps.vm.outputs.vm_id }} --username ajp-io)"
            fi
            exit 1
          elif [[ "$TEST_OUTCOME" == "skipped" || -z "$TEST_OUTCOME" ]]; then
            echo "‚ùå Embedded cluster installation test was SKIPPED due to earlier failures"
            echo "Please check the logs above to see what step failed."

            # Show VM info for debugging if VM was created
            if [[ -n "${{ steps.vm.outputs.vm_id }}" ]]; then
              echo ""
              echo "üîç Debug Information:"
              echo "VM ID: ${{ steps.vm.outputs.vm_id }}"
              echo "VM has been left running for debugging (24h TTL)"
              echo "You can SSH to it using: ssh \$(replicated vm ssh-endpoint ${{ steps.vm.outputs.vm_id }} --username ajp-io)"
            fi
            exit 1
          else
            echo "‚ùå Embedded cluster installation test had unexpected outcome: $TEST_OUTCOME"
            exit 1
          fi