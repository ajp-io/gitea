name: PR Test - Embedded Cluster

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'gitea/**'
      - 'manifests/**'
      - '.github/workflows/pr-test.yml'  # Allow testing the workflow itself

env:
  REPLICATED_APP: gitea-mastodon
  REPLICATED_API_ORIGIN: https://api.replicated.com/vendor

jobs:
  test-embedded-cluster:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install Replicated CLI
        run: |
          curl -s https://api.github.com/repos/replicatedhq/replicated/releases/latest \
          | grep "browser_download_url.*linux_amd64.tar.gz" \
          | cut -d : -f 2,3 \
          | tr -d \" \
          | wget -O replicated.tar.gz -qi -
          tar xf replicated.tar.gz
          sudo mv replicated /usr/local/bin/

      - name: Generate test version
        id: version
        run: |
          # Generate unique version for PR testing using PR number, run number, and commit SHA
          COMMIT_SHORT=$(git rev-parse --short HEAD)
          VERSION="2.0.0-pr${{ github.event.pull_request.number }}-r${{ github.run_number }}-${COMMIT_SHORT}"
          echo "test_version=$VERSION" >> $GITHUB_OUTPUT
          echo "Generated unique test version: $VERSION"

      - name: Package Helm chart
        run: |
          # Clean any existing packages
          rm -f manifests/*.tgz

          # Package the chart
          helm package gitea -d manifests -u
          echo "Packaged chart:"
          ls -la manifests/*.tgz

      - name: Create test release
        run: |
          # Create release on Unstable channel for testing
          replicated release create \
            --lint \
            --yaml-dir ./manifests \
            --promote Unstable \
            --version "${{ steps.version.outputs.test_version }}"
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}
          REPLICATED_APP: ${{ env.REPLICATED_APP }}

      - name: Create test VM
        id: vm
        run: |
          # Create VM for testing
          echo "Creating VM for PR testing..."
          VM_OUTPUT=$(replicated vm create \
            --distribution ubuntu \
            --version 22.04 \
            --instance-type r1.small \
            --name "pr-test-${{ github.event.pull_request.number }}" \
            --output json)

          echo "VM creation output:"
          echo "$VM_OUTPUT"

          # Try to extract VM ID - handle both object and array responses
          VM_ID=$(echo "$VM_OUTPUT" | jq -r 'if type == "array" then .[0].id else .id end')

          if [[ -z "$VM_ID" || "$VM_ID" == "null" ]]; then
            echo "‚ùå Failed to get VM ID from output"
            exit 1
          fi

          echo "vm_id=$VM_ID" >> $GITHUB_OUTPUT
          echo "Created VM: $VM_ID"

          # Wait for VM to be in running state
          echo "Waiting for VM to be in running state..."
          for i in {1..15}; do
            VM_INFO=$(replicated vm ls --output json | jq -r ".[] | select(.id==\"$VM_ID\")")
            VM_STATUS=$(echo "$VM_INFO" | jq -r '.status')
            SCHEDULING_STATUS=$(echo "$VM_INFO" | jq -r '.last_scheduling_status // "unknown"')

            echo "VM status check $i: $VM_STATUS (scheduling: $SCHEDULING_STATUS)"

            if [[ "$VM_STATUS" == "running" ]]; then
              echo "‚úÖ VM is now running!"
              break
            elif [[ "$VM_STATUS" == "error" || "$VM_STATUS" == "terminated" ]]; then
              echo "‚ùå VM failed to start (status: $VM_STATUS)"
              echo "VM details: $VM_INFO"
              exit 1
            elif [[ "$SCHEDULING_STATUS" == "failed" ]]; then
              echo "‚ùå VM scheduling failed"
              echo "VM details: $VM_INFO"
              exit 1
            fi

            sleep 10
          done

          # Final status check
          FINAL_INFO=$(replicated vm ls --output json | jq -r ".[] | select(.id==\"$VM_ID\")")
          FINAL_STATUS=$(echo "$FINAL_INFO" | jq -r '.status')
          if [[ "$FINAL_STATUS" != "running" ]]; then
            echo "‚ùå VM never reached running state (final status: $FINAL_STATUS)"
            echo "Final VM details: $FINAL_INFO"

            # If it's still queued after 2.5 minutes, leave it for debugging
            if [[ "$FINAL_STATUS" == "queued" ]]; then
              echo "‚ö†Ô∏è VM stuck in queued state - this might be due to resource availability"
              echo "Leaving VM $VM_ID for debugging (24h TTL will auto-cleanup)"
            fi
            exit 1
          fi
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}

      - name: Setup SSH and transfer files
        run: |
          # Setup SSH key for Compatibility Matrix
          mkdir -p ~/.ssh
          ssh-keyscan replicatedvm.com >> ~/.ssh/known_hosts

          # Get SCP endpoint for file transfers
          SCP_ENDPOINT=$(replicated vm scp-endpoint ${{ steps.vm.outputs.vm_id }})
          echo "SCP endpoint: $SCP_ENDPOINT"

          # Make scripts executable
          chmod +x scripts/test-embedded-install.sh

          # Transfer test files to VM using SCP endpoint
          scp -o StrictHostKeyChecking=no test/embedded-config.yaml $SCP_ENDPOINT:/tmp/config.yaml
          scp -o StrictHostKeyChecking=no scripts/test-embedded-install.sh $SCP_ENDPOINT:/tmp/test.sh

          echo "Files transferred successfully"
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}

      - name: Run embedded cluster installation test
        id: test
        run: |
          # Get SSH endpoint for connection
          SSH_ENDPOINT=$(replicated vm ssh-endpoint ${{ steps.vm.outputs.vm_id }})
          echo "SSH endpoint: $SSH_ENDPOINT"

          # Run the test script on the VM with the test version
          echo "Running embedded cluster installation test for version: ${{ steps.version.outputs.test_version }}"
          ssh -o StrictHostKeyChecking=no $SSH_ENDPOINT 'chmod +x /tmp/test.sh && sudo TEST_VERSION="${{ steps.version.outputs.test_version }}" /tmp/test.sh'

          echo "Test completed successfully!"
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}

      - name: Cleanup VM
        if: success()
        run: |
          if [[ -n "${{ steps.vm.outputs.vm_id }}" ]]; then
            echo "‚úÖ Test passed! Cleaning up VM: ${{ steps.vm.outputs.vm_id }}"
            replicated vm rm ${{ steps.vm.outputs.vm_id }} || true
            echo "VM cleanup completed"
          fi
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}

      - name: Clean up test artifacts
        if: always()
        run: |
          rm -f manifests/*.tgz
          echo "Cleaned up build artifacts"

      - name: Report test results
        if: always()
        run: |
          if [[ "${{ steps.test.outcome }}" == "success" ]]; then
            echo "‚úÖ Embedded cluster installation test PASSED"
            echo "The Gitea chart changes work correctly with embedded cluster deployment."
          else
            echo "‚ùå Embedded cluster installation test FAILED"
            echo "There may be issues with the chart changes. Please review the logs above."

            # Show VM info for debugging
            if [[ -n "${{ steps.vm.outputs.vm_id }}" ]]; then
              echo ""
              echo "üîç Debug Information:"
              echo "VM ID: ${{ steps.vm.outputs.vm_id }}"
              echo "VM has been left running for debugging (24h TTL)"
              echo "You can SSH to it using: ssh \$(replicated vm ssh-endpoint ${{ steps.vm.outputs.vm_id }})"
            fi
            exit 1
          fi