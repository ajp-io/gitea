name: PR Test - Embedded Cluster

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'gitea/**'
      - 'manifests/**'
      - '.github/workflows/pr-test.yml'  # Allow testing the workflow itself

env:
  REPLICATED_APP: gitea-mastodon
  REPLICATED_API_ORIGIN: https://api.replicated.com/vendor

jobs:
  test-embedded-cluster:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install Replicated CLI
        run: |
          curl -s https://api.github.com/repos/replicatedhq/replicated/releases/latest \
          | grep "browser_download_url.*linux_amd64.tar.gz" \
          | cut -d : -f 2,3 \
          | tr -d \" \
          | wget -O replicated.tar.gz -qi -
          tar xf replicated.tar.gz
          sudo mv replicated /usr/local/bin/

      - name: Generate test version
        id: version
        run: |
          # Generate unique version for PR testing
          VERSION="0.0.0-pr.${{ github.event.pull_request.number }}.${{ github.run_number }}"
          echo "test_version=$VERSION" >> $GITHUB_OUTPUT
          echo "Generated test version: $VERSION"

      - name: Package Helm chart
        run: |
          # Clean any existing packages
          rm -f manifests/*.tgz

          # Package the chart
          helm package gitea -d manifests -u
          echo "Packaged chart:"
          ls -la manifests/*.tgz

      - name: Create test release
        run: |
          # Create release on Unstable channel for testing
          replicated release create \
            --lint \
            --yaml-dir ./manifests \
            --promote Unstable \
            --version "${{ steps.version.outputs.test_version }}"
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}
          REPLICATED_APP: ${{ env.REPLICATED_APP }}

      - name: Create test VM
        id: vm
        run: |
          # Create VM for testing
          echo "Creating VM for PR testing..."
          VM_OUTPUT=$(replicated vm create \
            --distribution ubuntu \
            --version 22.04 \
            --instance-type r1.small \
            --name "pr-test-${{ github.event.pull_request.number }}" \
            --output json)

          echo "VM creation output:"
          echo "$VM_OUTPUT"

          # Try to extract VM ID - handle both object and array responses
          VM_ID=$(echo "$VM_OUTPUT" | jq -r 'if type == "array" then .[0].id else .id end')

          if [[ -z "$VM_ID" || "$VM_ID" == "null" ]]; then
            echo "❌ Failed to get VM ID from output"
            exit 1
          fi

          echo "vm_id=$VM_ID" >> $GITHUB_OUTPUT
          echo "Created VM: $VM_ID"

          # Wait for VM to be in running state
          echo "Waiting for VM to be in running state..."
          for i in {1..15}; do
            VM_INFO=$(replicated vm ls --output json | jq -r ".[] | select(.id==\"$VM_ID\")")
            VM_STATUS=$(echo "$VM_INFO" | jq -r '.status')
            SCHEDULING_STATUS=$(echo "$VM_INFO" | jq -r '.last_scheduling_status // "unknown"')

            echo "VM status check $i: $VM_STATUS (scheduling: $SCHEDULING_STATUS)"

            if [[ "$VM_STATUS" == "running" ]]; then
              echo "✅ VM is now running!"
              break
            elif [[ "$VM_STATUS" == "error" || "$VM_STATUS" == "terminated" ]]; then
              echo "❌ VM failed to start (status: $VM_STATUS)"
              echo "VM details: $VM_INFO"
              exit 1
            elif [[ "$SCHEDULING_STATUS" == "failed" ]]; then
              echo "❌ VM scheduling failed"
              echo "VM details: $VM_INFO"
              exit 1
            fi

            sleep 10
          done

          # Final status check
          FINAL_INFO=$(replicated vm ls --output json | jq -r ".[] | select(.id==\"$VM_ID\")")
          FINAL_STATUS=$(echo "$FINAL_INFO" | jq -r '.status')
          if [[ "$FINAL_STATUS" != "running" ]]; then
            echo "❌ VM never reached running state (final status: $FINAL_STATUS)"
            echo "Final VM details: $FINAL_INFO"

            # If it's still queued after 2.5 minutes, maybe try a different approach
            if [[ "$FINAL_STATUS" == "queued" ]]; then
              echo "⚠️ VM stuck in queued state - this might be due to resource availability"
              echo "Attempting to clean up and exit gracefully..."
              replicated vm rm "$VM_ID" --force || true
            fi
            exit 1
          fi
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}

      - name: Setup SSH and transfer files
        run: |
          # Setup SSH key for Compatibility Matrix
          mkdir -p ~/.ssh
          ssh-keyscan replicatedvm.com >> ~/.ssh/known_hosts

          # Get SSH endpoint
          SSH_ENDPOINT=$(replicated vm ssh-endpoint ${{ steps.vm.outputs.vm_id }})
          echo "SSH endpoint: $SSH_ENDPOINT"

          # Make scripts executable
          chmod +x scripts/test-embedded-install.sh

          # Transfer test files to VM
          scp -o StrictHostKeyChecking=no test/embedded-config.yaml $SSH_ENDPOINT:/tmp/config.yaml
          scp -o StrictHostKeyChecking=no scripts/test-embedded-install.sh $SSH_ENDPOINT:/tmp/test.sh

          echo "Files transferred successfully"
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}

      - name: Run embedded cluster installation test
        id: test
        run: |
          # Get SSH endpoint
          SSH_ENDPOINT=$(replicated vm ssh-endpoint ${{ steps.vm.outputs.vm_id }})

          # Run the test script on the VM with the test version
          echo "Running embedded cluster installation test for version: ${{ steps.version.outputs.test_version }}"
          ssh -o StrictHostKeyChecking=no $SSH_ENDPOINT 'chmod +x /tmp/test.sh && sudo TEST_VERSION="${{ steps.version.outputs.test_version }}" /tmp/test.sh'

          echo "Test completed successfully!"
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}

      - name: Cleanup VM
        if: always()
        run: |
          if [[ -n "${{ steps.vm.outputs.vm_id }}" ]]; then
            echo "Cleaning up VM: ${{ steps.vm.outputs.vm_id }}"
            replicated vm rm ${{ steps.vm.outputs.vm_id }} --force || true
            echo "VM cleanup completed"
          fi
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}

      - name: Clean up test artifacts
        if: always()
        run: |
          rm -f manifests/*.tgz
          echo "Cleaned up build artifacts"

      - name: Report test results
        if: always()
        run: |
          if [[ "${{ steps.test.outcome }}" == "success" ]]; then
            echo "✅ Embedded cluster installation test PASSED"
            echo "The Gitea chart changes work correctly with embedded cluster deployment."
          else
            echo "❌ Embedded cluster installation test FAILED"
            echo "There may be issues with the chart changes. Please review the logs above."
            exit 1
          fi